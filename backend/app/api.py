import os
import logging
from fastapi import APIRouter, Query, Body
from typing import Optional
from fastapi.responses import JSONResponse
from . import swapi_client, utils, models
from dotenv import load_dotenv
import asyncio

load_dotenv()

router = APIRouter()

PAGE_SIZE = 50

# Set up logging
logging.basicConfig(level=os.getenv("LOG_LEVEL", "INFO"))
logger = logging.getLogger("starwars-app")

@router.get("/people", response_model=models.PaginatedResponse)
async def get_people(
    page: int = Query(1, ge=1),
    search: Optional[str] = None,
    sort_by: Optional[str] = Query("name"),
    order: Optional[str] = Query("asc")
):
    logger.info(f"[PEOPLE] page={page} search={search} sort_by={sort_by} order={order}")
    start = (page - 1) * PAGE_SIZE
    end = start + PAGE_SIZE
    items = []
    swapi_page = 1
    while len(items) < end:
        data = await swapi_client.fetch_people(swapi_page)
        results = data.get("results", [])
        if not results:
            break
        items.extend(results)
        if not data.get("next"):
            break
        swapi_page += 1
    # Filter by name
    search = search or ""
    items = utils.filter_by_name(items, search)
    # Sort
    sorters = {
        "name": lambda x: x.get("name", ""),
        "created": lambda x: x.get("created", "")
    }
    sort_by = sort_by or "name"
    order = order or "asc"
    items = utils.sort_items(items, sort_by, order, sorters)
    paginated = items[start:end]
    total_count = len(items)
    next_page = page + 1 if end < total_count else None
    prev_page = page - 1 if page > 1 else None
    return models.PaginatedResponse(
        count=total_count,
        next=str(next_page) if next_page else None,
        previous=str(prev_page) if prev_page else None,
        results=paginated
    )

@router.get("/planets", response_model=models.PaginatedResponse)
async def get_planets(
    page: int = Query(1, ge=1),
    search: Optional[str] = None,
    sort_by: Optional[str] = Query("name"),
    order: Optional[str] = Query("asc")
):
    logger.info(f"[PLANETS] page={page} search={search} sort_by={sort_by} order={order}")
    # Calcular el offset real
    start = (page - 1) * PAGE_SIZE
    end = start + PAGE_SIZE
    items = []
    swapi_page = 1
    while len(items) < end:
        data = await swapi_client.fetch_planets(swapi_page)
        results = data.get("results", [])
        if not results:
            break
        items.extend(results)
        if not data.get("next"):
            break
        swapi_page += 1
    # Filter by name
    search = search or ""
    items = utils.filter_by_name(items, search)
    # Sort
    sorters = {
        "name": lambda x: x.get("name", ""),
        "created": lambda x: x.get("created", "")
    }
    sort_by = sort_by or "name"
    order = order or "asc"
    items = utils.sort_items(items, sort_by, order, sorters)
    paginated = items[start:end]
    total_count = len(items)
    next_page = page + 1 if end < total_count else None
    prev_page = page - 1 if page > 1 else None
    return models.PaginatedResponse(
        count=total_count,
        next=str(next_page) if next_page else None,
        previous=str(prev_page) if prev_page else None,
        results=paginated
    )

@router.post("/simulate-ai-insight")
async def simulate_ai_insight(payload: dict = Body(...)):
    name = payload.get("name", "")
    if not name:
        return JSONResponse(status_code=400, content={"error": "Missing 'name' in request body"})
    # Fake AI output
    description = f"{name} is a legendary figure in the Star Wars universe, known for their unique adventures and impact on the galaxy. (Generated by fake AI)"
    logger.info(f"[SIMULATE-AI-INSIGHT] name={name}")
    return {"insight": description} 